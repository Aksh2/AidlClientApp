package com.project.applicationa.utils

import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Log
import java.nio.charset.StandardCharsets
import java.security.KeyStore
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec
import kotlin.io.encoding.Base64
import kotlin.io.encoding.ExperimentalEncodingApi
import kotlin.text.split
import kotlin.text.toByteArray

object CryptoHelper {
    private const val KEY_ALIAS = "AppSymmetricKey"
    private const val ANDROID_KEYSTORE_PROVIDER = "AndroidKeyStore"
    private const val AES_MODE = "AES/GCM/NoPadding"
    private const val GCM_TAG_LENGTH_BITS = 128
    private const val IV_SEPARATOR =
        ":" // A character to separate IV and ciphertext in the combined string


    @get:Throws(Exception::class)
    val orCreateKey: SecretKey
        get() {
            val keyStore = KeyStore.getInstance(ANDROID_KEYSTORE_PROVIDER)
            keyStore.load(null)

            keyStore.getKey(KEY_ALIAS, null)?.let { key ->
                return key as SecretKey
            }

            val keyGenParameterSpec = KeyGenParameterSpec.Builder(
                KEY_ALIAS,
                KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
            )
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                .setKeySize(256)
                .setRandomizedEncryptionRequired(true)
                .build()

            val keyGenerator =
                KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEYSTORE_PROVIDER)
            keyGenerator.init(keyGenParameterSpec)
            return keyGenerator.generateKey()
        }

    @OptIn(ExperimentalEncodingApi::class)
    @Throws(Exception::class)
    fun String.encrypt(): String? {
        if (this.isEmpty()) {
            Log.e("Crypto", "Data to encrypt is empty")
            return null
        }
        try {
            val secretKey = orCreateKey
            val cipher = Cipher.getInstance(AES_MODE)
            cipher.init(Cipher.ENCRYPT_MODE, secretKey) // IV is generated by the provider

            val iv = cipher.iv
            if (iv == null || iv.isEmpty()) {
                Log.e("Crypto", "IV is null or empty after cipher init for encryption.")
                return null
            }

            val ciphertext = cipher.doFinal(this.toByteArray(StandardCharsets.UTF_8))

            // Encode IV and Ciphertext to Base64 strings
            val ivBase64 = Base64.encode(iv)
            val ciphertextBase64 = Base64.encode(ciphertext)

            // Combine them with a separator
            return "$ivBase64$IV_SEPARATOR$ciphertextBase64"

        } catch (e: Exception) {
            Log.e("Crypto", "Encryption to combined string failed", e)
            throw e
        }

    }

    @OptIn(ExperimentalEncodingApi::class)
    @Throws(Exception::class)
    fun String.decrypt(): String? {
        if (this.isEmpty()) {
            // Log.e("Crypto", "Combined encrypted data string is empty")
            return null
        }
        try {
            val parts = this.split(IV_SEPARATOR)
            if (parts.size != 2) {
                Log.e("Crypto", "Invalid combined encrypted data format.")
                return null // Or throw a specific format exception
            }

            val ivBase64 = parts[0]
            val ciphertextBase64 = parts[1]

            val iv = Base64.decode(ivBase64)
            val ciphertext = Base64.decode(ciphertextBase64)

            if (iv.isEmpty() || ciphertext.isEmpty()) {
                Log.e("Crypto", "Decoded IV or Ciphertext is empty.")
                return null
            }

            val secretKey = orCreateKey
            val cipher = Cipher.getInstance(AES_MODE)
            val spec = GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, spec)

            val decryptedBytes = cipher.doFinal(ciphertext)
            return String(decryptedBytes, StandardCharsets.UTF_8)

        } catch (e: IllegalArgumentException) {
            Log.e("Crypto", "Base64 decoding failed. Invalid Base64 string.", e)
            throw e // Or handle more gracefully
        } catch (e: Exception) {
            Log.e("Crypto", "Decryption from combined string failed", e)
            throw e
        }
    }
}
